[4mRunning "mochaTest:doc" (mochaTest) task[24m
    <section class="suite">
      <h1>TlsServer</h1>
      <dl>
        <dt>should end any open streams and stop when requested</dt>
        <dd><pre><code>server = new TlsServer(SERVER_OPTIONS);
server.start(function() {
  var stoppedEventsReceived = 0;
  var connection = tls.connect({
    port: PORT,
    key: CLIENT_KEY,
    cert: CLIENT_CERT,
    ca: [SERVER_CERT]
  }, function() {
    server.stop(function() {
      // TODO: I would rather the streams received end events first
      stoppedEventsReceived++;
    });
  });
  connection.on('end', function() {
    expect(stoppedEventsReceived).to.equal(1);
    done();
  });
});</code></pre></dd>
        <section class="suite">
          <h1>once started</h1>
          <dl>
            <dt>should accept TLS connections on the configured port and assign an external port for forwarding</dt>
            <dd><pre><code>var dataEventCount = 0;
var connection = tls.connect({
  port: PORT,
  key: CLIENT_KEY,
  cert: CLIENT_CERT
});
connection.setEncoding('utf8');
connection.on('data', function(data) {
  dataEventCount++;
  expect(data).to.equal('' + START_PORT);
  connection.end();
});
connection.on('end', function() {
  expect(dataEventCount).to.equal(1);
  done();
});</code></pre></dd>
            <dt>should accept multiple connections but immediately end connections if no more ports are available for forwarding</dt>
            <dd><pre><code>var errorCount = 0;
var connection1 = tls.connect({
  port: PORT,
  key: CLIENT_KEY,
  cert: CLIENT_CERT
});
connection1.setEncoding('utf8');
connection1.on('data', function(data) {
  expect(data).to.equal('' + START_PORT, 'connection1');
  var connection2 = tls.connect({
    port: PORT,
    key: CLIENT_KEY,
    cert: CLIENT_CERT
  });
  connection2.setEncoding('utf8');
  connection2.on('data', function(data) {
    expect(data).to.equal('' + (START_PORT + 1), 'connection2');
    var connection3 = tls.connect({
      port: PORT,
      key: CLIENT_KEY,
      cert: CLIENT_CERT
    });
    connection3.setEncoding('utf8');
    connection3.on('data', function(data) {
      expect(data).to.equal('' + (START_PORT + 2), 'connection3');
      var connection4 = tls.connect({
        port: PORT,
        key: CLIENT_KEY,
        cert: CLIENT_CERT
      });
      connection4.setEncoding('utf8');
      connection4.on('data', function(data) {
        errorCount++;
        expect(data).to.equal('error: no ports available for forwarding');
      });
      connection4.on('end', function() {
        connection3.end();
      });
    });
    connection3.on('end', function() {
      connection2.end();
    });
  });
  connection2.on('end', function() {
    connection1.end();
  });
});
connection1.on('end', function() {
  expect(errorCount).to.equal(1);
  done();
});</code></pre></dd>
            <dt>should reuse forwarded ports when they become available again</dt>
            <dd><pre><code>// NB. after the last test the ports available will have been reversed I think
// because the end events are emitted before the streams are actually stopped
// with the server which actually then happens after the events have been handled.
// If this seems confusing it's probaby because it is.

var errorCount = 0;
var connection1 = tls.connect({
  port: PORT,
  key: CLIENT_KEY,
  cert: CLIENT_CERT
});
connection1.setEncoding('utf8');
connection1.on('data', function(data) {
  expect(data).to.equal('' + (START_PORT + 2), 'connection1');
  var connection2 = tls.connect({
    port: PORT,
    key: CLIENT_KEY,
    cert: CLIENT_CERT
  });
  connection2.setEncoding('utf8');
  connection2.on('data', function(data) {
    expect(data).to.equal('' + (START_PORT + 1), 'connection2');
    var connection3 = tls.connect({
      port: PORT,
      key: CLIENT_KEY,
      cert: CLIENT_CERT
    });
    connection3.setEncoding('utf8');
    connection3.on('data', function(data) {
      expect(data).to.equal('' + START_PORT, 'connection3');
      var connection4 = tls.connect({
        port: PORT,
        key: CLIENT_KEY,
        cert: CLIENT_CERT
      });
      connection4.setEncoding('utf8');
      connection4.on('data', function(data) {
        errorCount++;
        expect(data).to.equal('error: no ports available for forwarding', 'connection4');
      });
      connection4.on('end', function() {
        connection2.end();
      });
    });
    connection3.on('end', function() {
      connection2.end();
    });
  });
  connection2.on('end', function() {
    var connection5 = tls.connect({
      port: PORT,
      key: CLIENT_KEY,
      cert: CLIENT_CERT
    });
    connection5.setEncoding('utf8');
    connection5.on('data', function(data) {
      // NB. If this test ever fails then it maybe because of a race condition.
      // as far as I can tell the end event is emmitted before the server has been
      // notified - however it is likely that the server will get the end for connection2
      // before it gets the connect for connection5 so maybe it's all good
      expect(data).to.equal('' + (START_PORT + 1), 'connection5');
      var connection6 = tls.connect({
        port: PORT,
        key: CLIENT_KEY,
        cert: CLIENT_CERT
      });
      connection6.setEncoding('utf8');
      connection6.on('data', function(data) {
        errorCount++;
        expect(data).to.equal('error: no ports available for forwarding', 'connection6');
      });
      connection6.on('end', function() {
        connection5.end();
      });
    });
    connection5.on('end', function() {
      connection1.end();
    });
  });
});
connection1.on('end', function() {
  expect(errorCount).to.equal(2);
  done();
});</code></pre></dd>
            <dt>should reject connections with unknown certificates</dt>
            <dd><pre><code>var secureConnectEventCount = 0;
var connection = tls.connect({
  port: PORT,
  key: UNKNOWN_CLIENT_KEY,
  cert: UNKNOWN_CLIENT_CERT
}, function() {
  secureConnectEventCount++;
});
connection.on('error', function(error) {
  expect(secureConnectEventCount).to.equal(0);
  done();
});</code></pre></dd>
            <dt>should reject connections without a certificate</dt>
            <dd><pre><code>var secureConnectEventCount = 0;
var connection = tls.connect({
  port: PORT
}, function() {
  secureConnectEventCount++;
});
connection.on('error', function(error) {
  expect(secureConnectEventCount).to.equal(0);
  done();
});</code></pre></dd>
            <section class="suite">
              <h1>and connected</h1>
              <dl>
                <dt>should pass</dt>
                <dd><pre><code>done();</code></pre></dd>
              </dl>
            </section>
          </dl>
        </section>
      </dl>
    </section>
    <section class="suite">
      <h1>Range</h1>
      <dl>
        <section class="suite">
          <h1>#pop</h1>
          <dl>
            <dt>should return the values in the range in ascending order until there are none left</dt>
            <dd><pre><code>range.pop(function(error, value) {
  expect(error).to.equal(null);
  expect(value).to.equal(START);
  range.pop(function(error, value) {
    expect(error).to.equal(null);
    expect(value).to.equal(START + 1);
    range.pop(function(error, value) {
      expect(error).to.equal(null);
      expect(value).to.equal(START + 2);
      range.pop(function(error, value) {
        expect(error.toString()).to.equal((new Error('No more values')).toString());
        done();
      });
    });
  });
});</code></pre></dd>
          </dl>
        </section>
        <section class="suite">
          <h1>#push</h1>
          <dl>
            <dt>should put popped values back in the range to be reused</dt>
            <dd><pre><code>range.push(START + 1, function(error) {
  expect(error).to.be.an('undefined');
  range.push(START + 2, function(error) {
    expect(error).to.be.an('undefined');
    range.pop(function(error, value) {
      expect(error).to.equal(null);
      expect(value).to.equal(START + 2);
      range.pop(function(error, value) {
        expect(error).to.equal(null);
        expect(value).to.equal(START + 1);
        range.pop(function(error, value) {
          expect(error.toString()).to.equal((new Error('No more values')).toString());
          done();
        });
      });
    });
  });
});</code></pre></dd>
            <dt>should error if a value is pushed that is already available</dt>
            <dd><pre><code>range.push(START + 1, function(error) {
  expect(error).to.be.an('undefined');
  range.push(START + 1, function(error) {
    expect(error.toString()).to.equal((new Error('Value has not been popped')).toString());
    done();
  });
});</code></pre></dd>
            <dt>should error if a value is pushed that is not valid for the array</dt>
            <dd><pre><code>range.push(START + 3, function(error) {
  expect(error.toString()).to.equal((new Error('Value is not valid for the range')).toString());
  done();
});</code></pre></dd>
            <dt>should work without a callback having to be specified</dt>
            <dd><pre><code>range.push(START);</code></pre></dd>
          </dl>
        </section>
      </dl>
    </section>

[32mDone, without errors.[39m
